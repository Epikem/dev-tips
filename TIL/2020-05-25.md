# TIL 2020-05-12

오늘 배운 것 & 한 것

--------------------------

## desc

### 디자인 씽킹

창의적 문제해결 방법론:
1. 적합성 : 문제가 올바라야.
2. 실현가능성
3. 지속성

과정:
1. 공감하기 : 연민과 구별., 관찰력.
인터뷰. 이미 나무를 보고 있다면 한걸음 물러나서 보라.

진짜문제;;지원자가 없다.

니즈(욕구)-인사이트(통찰).





문제정의

아이디어

프로토타입:3가지 검사

테스트하기







안녕하세요. 사이버 물리 시스템 배터리 팩 검수 공정 자동화 과제의 발표를 맡게 된 L4조의 이현우입니다.
먼저 발표 순서를 알려드리겠습니다. 발표는 이현우, 송희원, 신상혁 학우 순서대로 진행할 것입니다.

목차를 소개해드리겠습니다. 먼저 기존 프로세스에 대해 설명하고, 그 한계점에 대해 분석하여 저희가 개선한 방법을 제안할 것입니다. 그 다음 저희의 공정을 상세하게 설명하고, 구현 과정에서 발생한 문제들에 대해 나열하고 어떻게 해결하였는지 알려드리겠습니다. 마지막으로 기존 프로세스와 저희의 L4 프로세스를 비교하고 나서 시연을 보여드리도록 하겠습니다.

먼저 기존 프로세스인 단순 자동화에 대해 설명하도록 하겠습니다.

단순 자동화는 각 단위공정을 한 로봇이 맡아 공정을 자동화하는 프로세스입니다. 사람이 작업을 할 경우 쉬는 시간이 필요하고 일하는 시간이 제한적이지만, 단순 자동화를 도입하면 쉬는 시간이 필요하지 않고 생산 라인의 24시간 구동이 가능하다는 장점이 있습니다.

그러나 단순 자동화에는 한계가 있습니다. 각 단위공정별로 로봇을 사용하므로 병목이 되는 한 단위공정을 기준으로 전체 공정의 생산량이 결정되는 문제가 있습니다. 이 그림에서처럼 ur1은 제품을 집어 컨베이어에 적재, ur2는 제품을 검사한 후 파렛트에 적재하는 작업을 구현하여 ur1과 ur2의 단위공정 시간을 비교한 결과 ur1은 개당 31.43초, ur2는 개당 37.73초가 걸렸습니다.  

이는 각각 시간당 ur1은 114개, ur2는 95개의 제품을 처리할 수 있음을 나타내며, ur1이 시간당 114개의 제품을 처리할 수 있음에도 ur2의 공정에 의해 전체 공정의 생산량이 결정되는 병목 현상이 발생했음을 나타냅니다.

이제 이러한 병목현상을 해결하기 위해 저희가 고안한 방법을 소개하겠습니다.

앞에서 보았던 공정의 병목현상이 UR2에 치우친 워크로드로 인해 발생하는 것임을 알아내었고, 이를 해결하기 위해 UR1이 ur2의 작업을 돕는 것이 가능한 공정을 설계하였습니다. 위 그림에서 ur2가 제품의 불량 검사를 하는 등 바쁜 상태이면 ur1가 제품을 바로 컨베이어에 보내지 않고

이렇게  ur1 옆에 있는 암실에서 제품을 검사한 후 컨베이어에 올림으로써 ur2의 업무 부담을 줄여주도록 하였습니다.

이제 L4 프로세스에 대한 자세한 공정의 구현을 송희원 학우가 설명할 것입니다.






```py
import time
import queue

UR1Actions=queue.SimpleQueue() # queue.Queue() on python2
UR2Actions=queue.SimpleQueue()

def ur1_move_to(pos, ori):
    UR1Actions.put(['move_to', pos, ori])

def ur1_open_gripper():
    UR1Actions.put(['open_gripper'])
    
def ur1_close_gripper():
    UR1Actions.put(['close_gripper'])

def handleStep():
    action=UR1Actions.get()
    if(action[0]=='move_to'):
        ur1_move_to_impl(action[1], action[2])
    elif(action[0]=='open_gripper'):
        ur1_open_gripper_impl()
    elif(action[0]=='close_gripper'):
        ur1_close_gripper_impl()

def __main__():
    ur1_move_to(somewhere,to)
    ur1_open_gripper()
    ...
    ur1_close_gripper()
    ur1_move_to(somewhere,to)

    while(True):
        handleStep()
        time.sleep(0.1)

```
















## tags
- \#TIL, \#blog, \#cloude, \#aws

--------------------------


 