# TIL 2020-08-10

오늘 배운 것 & 한 것

--------------------------

## 어제 한 일

## 할 일
- [x] 서버 짜기
  - [ ] 필요 api 상세 분석
  - [ ] 
- [ ] git commit message 템플릿 팀에 도입하기
- [ ] 추적 알고리즘 설계
- [ ] 백준 강의 문제풀이 및 수강
- [ ] bada_audio 알고리즘 개선


### 나중
- [ ] cfn [ssm](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html#dynamic-references-ssm-secure-strings) 적용 고려
- [ ] cfn autoscaling 적용:
  - https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/example-templates-autoscaling.html
  - https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html
- [ ] express js 등 서버 로그 분할. 
- [ ] test 추가
- [ ] ci/cd - cfn 연결. 빌드/개발/배포 파이프라인 구축

**중요**
- [ ] 기능 분석, 설계문서 작성

- [ ] 배스천 호스트 구조 상세문서 작성
- [ ] [aws cloudformation ec2 모범 시나리오](https://aws.amazon.com/ko/blogs/infrastructure-and-automation/best-practices-for-deploying-ec2-instances-with-aws-cloudformation/) 읽고 적용하기

- [ ] uml 시나리오 작성
- [ ] 예외사례 생각하기 (spoof, ddos 등)

### 
- [ ] cloudformer 사용불가 - 디딤나우 문의 otp 인증 필요

## 배운 것 & 한것 

### 필요 api 구현 분석, db 설계 재평가

#### 로그인
구글id와 맥주소로 로그인을 한다.

### 접촉
스캔했던 기록들을 클라이언트가 보내주면 서버에 정보를 저장하고, 접촉 조회를 실행하여 접촉자인지 알려준다.
db의 부담을 줄이기 위해 접촉 기록을 받아놓기만 했다가 나중에 몰아서 처리하는 것이 좋을 것이다.
개인 테이블에 저장하려면?? 

### 접촉 조회
개인 테이블에서 다른 접촉자가 있는지 검색하여 결과를 알려준다.
이는 my_mac을 가진 레코드 전체를 scan에서 찾음으로써 구현할 수 있을 것이다. 그렇다면 굳이 개인 테이블을 따로 만들 필요가 없다. 다만 성능을 위해 인덱스를 만들 필요가 있다.

### 확진자 신고


### 회복


### api 개발

설계 없이 개발하려다 보니 예외사항같은거나 구체적인게 점점 생각할게 많아지면서 머릿속이 복잡해지고 있다. 일단 정리를 좀 하자.

- login, scan, infect등 몇 기능 구현함.
- 여러 세션을 관리할 방안을 찾지 못함 (postman collection은 순차적)
- 그냥 login api를 써서 여러 계정을 나타내도록 함.
- 성공 케이스 1에 대해서만이 아니라, 실패, 예외 등 모든 케이스들에 대해 테스트 작성 필요.
- 스캔이 유저가 없는 맥에 대해 스캔하게 될 수도 있다. 그런데 나중에 해당 맥을 가진 유저가 회원가입(로그인)을 한다면??
  : 따라서 맥을 스캔하는 대로 일단 유저 테이블에 추가한 다음, 나중에 로그인 요청에서는 다음과 같은 케이스들을 고려해야 한다:
  1. mac, google_id가 없는 경우 -> 그냥 생성한다.
  2. 해당 mac을 가진 유저만 존재하는 경우 -> 해당 정보에 google_id 정보를 추가해 준다.
  3. mac, google_id가 있는 경우 -> 만약 mac이 다르다면?? -> google_id 하나가 여러 맥을 가질 수 있다.
  -> association 필요. 만약 association, 정규화를 하지 않는다면 -> 그냥 레코드를 추가한다. findOrCreate에서 애초에 mac, google_id를 where조건으로 사용하므로 생각해보니 mac이 다른 경우는 일어나지 않는다. 그러나 맥만 가지고 있던 유저가 회원가입하는 것인지에 대한 체크를 하기 위해 mac, google_id로 찾기 전에 먼저 mac만으로 찾아보아야 한다. login 시나리오의 서버 동작 명세 필요.

- 모든 api에서 필요 session 정보가 없을 경우 Login으로 redirect하는 방법
- morgan 사용하기
- request의 세션정보를 우선적으로 사용하고, 없으면 request의 정보를 사용하는 과정 단순화

#### 로그인 시나리오들:

1. 맥으로 유저를 찾는다.
  있을 경우: 구글 아이디로 해당 유저 정보를 업데이트 시킨다.
  없을 경우:
2. 맥과 구글 아이디로 유저를 생성한다.
3. 세션의 유저 정보를 업데이트한다.
  
#### 순차적 접촉 기본 시나리오:

1. 계정 1로 로그인
2. 계정 2의 맥정보를 가진 스캔 기록 업로드
3. 계정 1을 확진자로 표시
- 계정 1이 확진자임을 체크한다.
4. 계정 2로 로그인
5. 긴급 동기화 요청 전송
- 계정 2가 접촉자임을 체크한다.

이제 이 시나리오를 구현하기 위해 서버측을 구현하도록 해 보자. 서버측이 해야 할 것은 무엇인가??
스캔 기록은 db에 있고, 계정 2가 동기화 요청을 보낼 때, 계정 2의 스캔 기록을 찾을 수 있는가?? 생각해보니 계정 1이 스캔 기록을 보냈기 때문에 안되나?? 어떤 api에서 어떤 식으로 계정 2를 접촉자 표시를 해야 하는가??

확진 표시를 할 때, 해당 유저를 기준으로 접촉 전파를 해야 한다. 해당 유저의 맥 주소로 접촉 주소들을 모두 찾아서 상태 갱신이 필요하다.

생각할 게 꽤 있다.
1. 스캔 동기화시 or로 하게 되면 보안이 취약해지고, (해커의 스팸으로 체인 신빙성이 떨어질 수 있다.)
2. and로 하게 되면 양쪽이 모두 어플을 사용해야 하므로 실현가능성이 더더욱 낮아진다.
3. my_mac으로 검색할지, scan_mac으로 검색할지도 의문이다.
4. 자기 테이블이라 생각하고 scan_mac들을 탐색한다 하더라도, 접촉 전파시에는 그러한 정보들이 신뢰가능한지의 여부가 중요해지는데, 현재 방식으로는 조작이 너무나도 쉬운 상태이다.
5. 일단. 걱정하지 말고 그냥 해보는게 우선이라면, 그냥 각 my_mac기준으로 bfs재귀 탐색을 구현하면 될거 같다.
6. 그런데, my_mac->scan_mac이렇게 단방향이라면, 반대쪽에서 스캔을 했음에도 찾지 못하는 경우가 생길 수 있지 않는가??

그렇다면, 다른 한 쪽이 사용자가 아닐 때 (등록된 구글 아이디가 없는 경우), 임의적으로 스캔 기록을 양방향으로 등록시키도록 하고, 만약 양쪽이 사용자일 때에는 서로 대조를 하여 동기화하는 것으로 한다면 어떨까??

일단 구현을 간단히 하기 위해, 현재로서는 그냥 my_mac, scan_mac양방향으로부터 재귀 탐색을 하도록 하는 것이 괜찮을 듯 싶다.

이러한 문제가 생기는 원인이, 현재 테이블 설계가 스캔이 양방향 대칭으로 이루어지는 것을 가정하여 되었기 때문이다.
만약 스캔의 양방향 대칭성이 보장된다면, 각 my_mac에서만 탐색하여 재귀를 돌려도 모든 탐색을 할 수 있다. 그러나 대칭성이 보장되지 않는다면 곤란해진다.

그리고, 방문 기록은 어떻게 해야 할까?? 맥 주소를 기준으로 탐색해나가므로 알고리즘 문제 풀듯이 노드의 방문 여부를 정수로 인덱싱하는 visited 배열 같은 것을 사용할 수 없다. 그렇다면 오늘 뵈었던 분의 말씀대로 맥 주소를 정수화하여 계산하는 것이 유효할지도 모른다.

찾아본 결과, 맥 주소를 정수화하면 int 범위가 아닌 long 범위가 나올 정도로 범위가 크다. 그렇다면 당연히 visited배열을 만들 수도 없을 것이다. 그냥 dictionary를 쓰는 것이 일단 나을 거 같다.

### 캡스톤 web interface 저장소 분석

https://github.com/hello-robot/stretch_web_interface

언제하누

## tags
- \#TIL, \#blog, \#vscode, \#prj

--------------------------